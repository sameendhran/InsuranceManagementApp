City Entity - Negative Scenarios Handled
----------------------------------------

1. Null or blank city name
- Why: Prevents saving empty or whitespace-only names
- What: Throws CityException from validateCity() using isBlank()

2. Duplicate name on add
- Why: Prevents adding city with the same name (case-insensitive)
- What: Checked in addCity() using findByCityNameIgnoreCase()

3. Duplicate name on update
- Why: Prevents renaming a city to a name already used by another city
- What: Checked in updateCity() by comparing existing ID

4. Case-insensitive match
- Why: User may input mixed-case city names (e.g., chennai, CHENNAI)
- What: Handled via @NamedQuery and findByCityNameIgnoreCase()

5. Invalid ID (<= 0) in get/update
- Why: Prevents processing invalid negative or zero IDs
- What: Checked in service layer before calling BO

6. Fetch non-existing ID
- Why: Ensures error is thrown if no city with given ID exists
- What: Handled using orElseThrow() in BO

7. Get all when DB is empty
- Why: Avoids returning null or empty silently
- What: Throws CityException if findAll() is empty

8. Special characters in name
- Why: To restrict city names to valid input (letters and space only)
- What: Regex [a-zA-Z ]+ used in validateCity()

9. Name length > 100 characters
- Why: Prevents saving very long names which may cause layout or DB issues
- What: Checked with city.getCityName().length() > 100

Optional Improvements
---------------------

- Add createdAt, updatedAt
  > Why: Helpful for audit trail and tracking changes

- Use @Valid at controller level
  > Why: Spring will auto-reject bad inputs before BO is hit

- Handle global errors via @ControllerAdvice
  > Why: Centralized exception handling across all controllers
